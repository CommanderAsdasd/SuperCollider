/******************************************************************************/
// Thomas Klinkenberg 2017
// https://github.com/Thomasklinkenbergmusic/SuperCollider
/******************************************************************************/

/*******************************************************************************
| Deterministic UGens |
-----------------------
First of all the definition of determinism: "The philosophical doctrine that
every state of affairs, including every human event, act, and decision, is the
inevitable consequence of antecedent states of affairs." Everything that happens
is determined. In this case SuperCollider refers to UGens whose resulting
behavior is entirely determined by its initial state and inputs, and which is
not random or stochastic.

So these generator UGens always give the right output if we manage to give the
right input. These UGens are used to generate sound (like a oscillator),
impulses and controlling other parameters (like a LFO).

Here are some examples of the most basic deterministic UGens. If you're new to
SuperCollider, make sure to lookup the data in the post window. It's important
to know exactly what you are generating! Lookup the helpfile (cmd+D or
control+D) for more information on the UGens.
*******************************************************************************/

/*******************************************************************************
| SinOsc |
----------
"interpolating sine wavetable oscillator" - Generates a sine wave
*/

// Basic sine wave with the value multiplied by 0.5
{SinOsc.ar(440, 0, 0.25, 0)}.play;
// Sine on control rate, no audio output (check post window)
{SinOsc.kr(1, 0, 1).poll}.play;
// Sine with multiplied value and added value (check post window)
{SinOsc.kr(1, 0, 50, 100).poll}.play;
// This example is the same as above (check post window)
{SinOsc.kr(1).range(50, 150).poll}.play;

// Sine with a modulated frequency - modulated by a SinOsc.kr with a low
// frequency (LFO Low Frequency Oscillator)
{SinOsc.ar(SinOsc.kr(2, 0, 100, 400), 0, 0.25)}.play;
// Sine with a modulated volume
{SinOsc.ar(220, 0, SinOsc.kr(2, 0, 0.3, 0.25))}.play;
// FM synthesis - frequency is modulated by a SinOsc.kr with a high frequency
{SinOsc.ar(SinOsc.kr(110, 0, 220, 440), 0, 0.25)}.play;
// Phase modulation
{SinOsc.ar(440, SinOsc.kr(880), 0.25)}.play;

// Sine over both channels (L+R)
{SinOsc.ar([440,440], 0, 0.3)}.play;
// Same as above, but instead of an array ( [] notation) a "!2" is used (the
// "!" is a duplicate function)
{SinOsc.ar(440!2, 0, 0.3)}.play;
// Stereo FM synthesis
( {SinOsc.ar([SinOsc.kr(110, 0, 200, 440),
	          SinOsc.kr(110, 0, 200, 880)],0, 0.25)}.play; )

// FM synthesis with a random frequency (randomly generated by rrand)
// Try to trigger it multiple times
{SinOsc.ar(SinOsc.kr(rrand(10, 50), 0, 220, 440)!2, 0, 0.25)}.play;
// FM synthesis with stereo random frequencies
// Try to trigger it multiple times
{SinOsc.ar({SinOsc.kr(rrand(10, 50), 0, 220, 440)}!2, 0, 0.25)}.play;

/*
Explanation: In the first example "FM synthesis with random frequency" a
frequency is randomly generated by the Math class rrand. The rrand is being
trigger ONCE and then being copied over two channels by the !2 function
(! = duplicate). In the second example the SinOsc.kr with the rrand is being
defined as a FUNCTION. Its put between curly brackets -> {}. Instead of
duplicating a generated number, the duplicate function executes a random
function twice. Now we have two SinOsc.kr with both random generated numbers.
*******************************************************************************/

/*******************************************************************************
| Pulse and LFPulse |
---------------------
The Pulse and LFPulse are both pulse wave (also known as square wave)
oscillators. The Pulse signal is band limited and the LFPulse signal is non
-band-limited. This basically means that the pulse wave is filterd to prevent
aliasing. For more information band limiting and aliasing here are some
wikipedia links:

"https://en.wikipedia.org/wiki/Oversampling"
"https://en.wikipedia.org/wiki/Undersampling"

If you don't want to get too technical, lets say for now thats its better to use
Pulse.ar for audio output and LFPulse for other modulation. Look at the first
example closely and check the post window to see what it does!
*/

s.scope; // Active the server scope

// Both on control rate, no audio output (check post window)
{LFPulse.kr(1, 0, 0.5, 1).poll}.play;
{Pulse.kr(1, 0.5, 1).poll}.play;

// Pulse wave on both channels (L+R) with the value multiplied by 0.5
{Pulse.ar(220!2, 0.5, 0.25)}.play;
// Pulse wave with the frequency modulated by a LFPulse
{Pulse.ar(LFPulse.kr(2, 0, 0.5, 110, 110)!2, 0.5, 0.25)}.play;
// Same as above but the frequency modulater is replaced by a Pulse. Listen to
// the difference.
{Pulse.ar(Pulse.kr(2, 0.5).range(110, 220)!2, 0.5, 0.25)}.play;
// Pulse wave with even more frequency modulation
( {Pulse.ar(LFPulse.kr(LFPulse.kr(0.5, 0, 0.5, 20, 1),
	                   0, 0.5, 220, 220)!2, 0.5, 0.25)}.play; )

// Pulse wave with pulse-width modulation
{Pulse.ar(220!2, SinOsc.kr(0.35, 0, 0.4, 0.5), 0.25)}.play;
/******************************************************************************/