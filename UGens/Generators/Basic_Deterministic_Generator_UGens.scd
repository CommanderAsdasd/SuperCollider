/******************************************************************************/
// Thomas Klinkenberg 2017
// https://github.com/Thomasklinkenbergmusic/SuperCollider
/******************************************************************************/

/*******************************************************************************
| Deterministic UGens |
-----------------------
First of all the definition of determinism: "The philosophical doctrine that
every state of affairs, including every human event, act, and decision, is the
inevitable consequence of antecedent states of affairs." Everything that happens
is determined. In this case SuperCollider refers to UGens whose resulting
behavior is entirely determined by its initial state and inputs, and which is
not random or stochastic.

These UGens always give the same output which depends on the input. These UGens
are mainly used to generate sound (like a oscillator), impulses and controlling
other parameters (like a LFO).

Here are some examples of the most basic deterministic UGens. If you're new to
SuperCollider, make sure to lookup the data in the post window. It's important
to know exactly what you are generating! Lookup the helpfile (cmd+D or
control+D) for more information on the UGens.
*******************************************************************************/

/*******************************************************************************
| SinOsc |
----------
"interpolating sine wavetable oscillator" - Generates a sine wave
*/

// Basic sine wave with the value multiplied by 0.25
{SinOsc.ar(440, 0, 0.25, 0)}.play;
// Sine on control rate, no audio output (check post window)
{SinOsc.kr(1, 0, 1).poll}.play;
// Sine with multiplied value and added value (check post window)
{SinOsc.kr(1, 0, 50, 100).poll}.play;
// This example is the same as above (check post window)
{SinOsc.kr(1).range(50, 150).poll}.play;

// Sine with a modulated frequency - modulated by a SinOsc.kr with a low
// frequency (LFO Low Frequency Oscillator)
{SinOsc.ar(SinOsc.kr(2, 0, 100, 400), 0, 0.25)}.play;
// Sine with a modulated volume
{SinOsc.ar(220, 0, SinOsc.kr(2, 0, 0.3, 0.25))}.play;
// FM synthesis - frequency is modulated by a SinOsc.kr with a high frequency
{SinOsc.ar(SinOsc.kr(110, 0, 220, 440), 0, 0.25)}.play;
// Phase modulation
{SinOsc.ar(440, SinOsc.kr(880), 0.25)}.play;

// Sine over both channels (L+R)
{SinOsc.ar([440,440], 0, 0.25)}.play;
// Same as above, but instead of an array ( [] notation) a "!2" is used (the
// "!" is a duplicate function)
{SinOsc.ar(440!2, 0, 0.25)}.play;
// Stereo FM synthesis
( {SinOsc.ar([SinOsc.kr(110, 0, 200, 440),
	          SinOsc.kr(110, 0, 200, 880)],0, 0.25)}.play; )

// FM synthesis with a random frequency (randomly generated by rrand)
// Try to trigger it multiple times
{SinOsc.ar(SinOsc.kr(rrand(10, 50), 0, 220, 440)!2, 0, 0.25)}.play;
// FM synthesis with stereo random frequencies
// Try to trigger it multiple times
{SinOsc.ar({SinOsc.kr(rrand(10, 50), 0, 220, 440)}!2, 0, 0.25)}.play;

/*
Explanation: In the first example "FM synthesis with random frequency" a
frequency is randomly generated by the Math class rrand. The rrand is being
trigger ONCE and then being copied over two channels by the !2 function
(! = duplicate). In the second example the SinOsc.kr with the rrand is being
defined as a FUNCTION. Its put between curly brackets -> {}. Instead of
duplicating a generated number, the duplicate function executes a random
function twice. Now we have two SinOsc.kr with both random generated numbers.
*******************************************************************************/

/*******************************************************************************
| Pulse & LFPulse |
---------------------
The Pulse and LFPulse are both pulse wave (also known as square wave)
oscillators. The Pulse signal is band limited and the LFPulse signal is non
-band-limited. This basically means that the pulse wave is filterd to prevent
aliasing. For more information band limiting and aliasing here are some
wikipedia links:

"https://en.wikipedia.org/wiki/Oversampling"
"https://en.wikipedia.org/wiki/Undersampling"

If you don't want to get too technical, lets say for now thats its better to use
Pulse.ar for audio output and LFPulse for other modulation. Look at the first
example closely and check the post window to see what it does!
*/

// Both on control rate, no audio output (check post window)
{Pulse.kr(1, 0.5, 1).poll}.play;
{LFPulse.kr(1, 0, 0.5, 1).poll}.play;

// Pulse wave on both channels (L+R) with the value multiplied by 0.25
{Pulse.ar(220!2, 0.5, 0.25)}.play;
// Pulse wave with the frequency modulated by a LFPulse
{Pulse.ar(LFPulse.kr(2, 0, 0.5, 110, 110)!2, 0.5, 0.25)}.play;
// Same as above but the frequency modulater is replaced by a Pulse. Listen to
// the difference.
{Pulse.ar(Pulse.kr(2, 0.5).range(110, 220)!2, 0.5, 0.25)}.play;
// Pulse wave with even more frequency modulation
( {Pulse.ar(LFPulse.kr(LFPulse.kr(0.5, 0, 0.5, 20, 1),
	                   0, 0.5, 220, 220)!2, 0.5, 0.25)}.play; )

// Pulse wave with pulse-width modulation
{Pulse.ar(220!2, SinOsc.kr(0.35, 0, 0.4, 0.5), 0.25)}.play;
// Pulse wave with amplitude modulation
{Pulse.ar(220!2, 0.5, LFPulse.kr(10, 0, 0.5, 1))}.play;
/******************************************************************************/

/*******************************************************************************
| Saw, LFSaw & VarSaw |
-----------------------
The Saw and LFSaw are both saw wave oscillators. The Saw UGen is band limitid
and the LFSaw non-band-limited. Same as the pusle wave oscillators. Use the Saw
object for audio output and check the first example post window.

The VarSaw is Sawtooth-triangle oscillator with a variable duty. This means the
VarSaw is a different waveform depending on the width that has been set by the
user. The default of the width is 0.5 and that resulst in a triangle wave. Look
at the examples.
*/

// Both on control rate, no audio output (check post window)
{Saw.kr(1, 1).poll}.play;
// {LFSaw.kr(1, 0.5, 1).poll}.play
// A frequency with a negative value inverses the sawtooth direction
{LFSaw.kr(-1, 0.5, 1).poll}.play

// Saw wave on both channels (L+R) with the value multiplied by 0.25
{Saw.ar(220!2, 0.25)}.play;
// Saw wave with the frequency modulated by a LFSaw
{Saw.ar(LFSaw.kr(-5, 1, 110, 330)!2, 0.25)}.play;

// Control rate, no audio output (check post window and scope)
{VarSaw.kr(1, 0, 0.5, 1).poll.scope}.play;
// VarSaw on control rate with a 0.95 width (check post window and scope)
{VarSaw.kr(1, 0, 0.95, 1).poll.scope}.play;
// VarSaw on control rate with a 0.05 width (check post window and scope)
{VarSaw.kr(1, 0, 0.05, 1).poll.scope}.play;
// VarSaw with the frequency modulation and width modulation
( {VarSaw.ar(SinOsc.kr(2, 0, 110, 330)!2, 0,
	         SinOsc.kr(2.5, 0, 0.3, 0.5), 0.25)}.play )
// This VarSaw gives the same result as a Saw
{VarSaw.ar(220!2, 0, 0, 0.25)}.play;

/******************************************************************************/

/*******************************************************************************
| LFTri |
---------
LFTri is a non-band-limited triangle oscillator.

NOTE: Negative values DON'T work with LFTri
*/

// Both on control rate, no audio output (check post window)
{LFTri.kr(1, 0, 1).poll}.play;

// {LFTri.ar(220!2, 0, 0.25)}.play;

/******************************************************************************/
